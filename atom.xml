<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sergiojune | 梦开始的地方</title>
  
  <subtitle>路在，人就在</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sergiojune.com/"/>
  <updated>2018-10-10T10:35:55.414Z</updated>
  <id>http://sergiojune.com/</id>
  
  <author>
    <name>sergiojune</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构之栈的理解及实现</title>
    <link href="http://sergiojune.com/2018/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A0%88%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://sergiojune.com/2018/10/10/数据结构之线性栈的理解及实现/</id>
    <published>2018-10-10T10:35:43.532Z</published>
    <updated>2018-10-10T10:35:55.414Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-栈的理解"><a href="#1-栈的理解" class="headerlink" title="1.栈的理解"></a>1.栈的理解</h4><p>栈是一种只允许从一端插入或者删除数据的结构，就比如你向弹匣装子弹，只能在头部装，在打枪的时候，也是在头部的子弹先发射出去，简单地说就是后进先出。</p><p>栈的插入操作叫做进栈，也称压栈、入栈。<br>栈的删除操作叫做出栈，也叫弹栈。</p><h4 id="2-栈的应用"><a href="#2-栈的应用" class="headerlink" title="2.栈的应用"></a>2.栈的应用</h4><p>我们在浏览网页的时候，都会有个后退的按钮，这个就是用栈来实现的，还有就是大部分软件的可撤销操作，也都是用栈实现的。</p><h4 id="3-栈的结构需要实现的方法"><a href="#3-栈的结构需要实现的方法" class="headerlink" title="3.栈的结构需要实现的方法"></a>3.栈的结构需要实现的方法</h4><p>结构：<br>  需要声明栈的容量以及当前栈的长度（就是下一个元素插入的位置或者当前栈顶的元素位置）</p><p>方法：</p><ol><li>InitStack(*s):  初始化操作，建立一个空栈。</li><li>DestoryStack(*s):  若栈存在，就销毁栈</li><li>ClearStaack(*s):  清空栈</li><li>StackEmpty(*s):  判断栈是否为空，若为空，返回true</li><li>GetTop(*s, e): 若栈顶存在，就用 e 来返回栈定元素</li><li>Push(*s， e): 向栈顶插入元素，并用 e 返回栈顶元素</li><li>Pop(*s, e): 若站栈顶存在，就删除栈顶元素并赋值给 e 返回</li><li>StackLength(): 获取栈的长度</li></ol><h4 id="4-用-c-语言实现栈"><a href="#4-用-c-语言实现栈" class="headerlink" title="4.用 c 语言实现栈"></a>4.用 c 语言实现栈</h4><p>有空补上</p><h4 id="5-用-Java-语言实现栈"><a href="#5-用-Java-语言实现栈" class="headerlink" title="5. 用 Java 语言实现栈"></a>5. 用 Java 语言实现栈</h4><h5 id="顺序存储结构实现栈"><a href="#顺序存储结构实现栈" class="headerlink" title="顺序存储结构实现栈"></a>顺序存储结构实现栈</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayStack implements Stack &#123;</span><br><span class="line">    int length;</span><br><span class="line">    int[] arr;</span><br><span class="line"></span><br><span class="line">    public ArrayStack(int capacity)&#123;</span><br><span class="line">        arr = new int[capacity];</span><br><span class="line">        length = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 默认创建长度为10的数组</span><br><span class="line">     public ArrayStack()&#123;</span><br><span class="line">        this(10);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return length == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int length() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        if(length == 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;不存在栈顶元素&quot;);</span><br><span class="line"></span><br><span class="line">        return arr[length - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if(length == 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;出栈失败，栈顶为空&quot;);</span><br><span class="line"></span><br><span class="line">        int e = arr[length - 1];</span><br><span class="line">        length --;</span><br><span class="line">        // 当栈长度小于当前容量的4倍时就进行数据搬移，防止占用大量空间</span><br><span class="line">        // 这个时候也要判断 arr.length / 2 != 0，因为不能创建长度为0的数组</span><br><span class="line">        // 4倍才进行缩小是因为防止时间复杂度进行了震荡</span><br><span class="line">        if(length == arr.length / 4 &amp;&amp; arr.length / 2 != 0)</span><br><span class="line">            resize(arr.length / 2);</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void push(int e) &#123;</span><br><span class="line">        if(length &gt;= arr.length)</span><br><span class="line">            resize(length * 2);  // 扩容为当前两倍</span><br><span class="line"></span><br><span class="line">        arr[length] = e;</span><br><span class="line">        length ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 动态扩容栈</span><br><span class="line">    public void resize(int capacity)&#123;</span><br><span class="line">        int [] newArr = new int[capacity];</span><br><span class="line">        for(int i = 0; i &lt; length; i ++)&#123;</span><br><span class="line">            newArr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr = newArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        res.append(String.format(&quot;capacoty:%d, length:%d\n&quot;, arr.length, length));</span><br><span class="line">        res.append(&quot;ArrayStack: tail [&quot;);</span><br><span class="line">        for(int i = 0; i &lt; length; i++)&#123;</span><br><span class="line">            res.append(arr[i]);</span><br><span class="line">            if(i != length - 1)</span><br><span class="line">                res.append(&quot;, &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(&quot;] top&quot;);</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedListStack implements Stack &#123;</span><br><span class="line"></span><br><span class="line">    class Node&#123;</span><br><span class="line">        int data;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        public Node(int data, Node next)&#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Node(int data)&#123;</span><br><span class="line">            this(data, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int length;</span><br><span class="line">    Node head;</span><br><span class="line"></span><br><span class="line">    public LinkedListStack()&#123;</span><br><span class="line">        length = 0;</span><br><span class="line">        // 虚拟头节点</span><br><span class="line">        head = new Node(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int length() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return length == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void push(int e) &#123;</span><br><span class="line">        // 直接插入链表的头部</span><br><span class="line">        Node node = new Node(e);</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if(length == 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;出栈失败，当前栈为空&quot;);</span><br><span class="line"></span><br><span class="line">        Node node = head.next;</span><br><span class="line">        head.next = node.next;</span><br><span class="line">        length --;</span><br><span class="line">        return node.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        if(length == 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;出栈失败，当前栈为空&quot;);</span><br><span class="line"></span><br><span class="line">        return head.next.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        Node node = head.next;</span><br><span class="line">        res.append(String.format(&quot;length: %d\n&quot;, length));</span><br><span class="line">        res.append(&quot;LinkedList: &quot;);</span><br><span class="line">        for(int i = 0; i &lt; length; i++)&#123;</span><br><span class="line">            res.append(node.data);</span><br><span class="line">            res.append(&quot; --&gt; &quot;);</span><br><span class="line">            node =  node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(&quot;NULL&quot;);</span><br><span class="line"></span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-栈的理解&quot;&gt;&lt;a href=&quot;#1-栈的理解&quot; class=&quot;headerlink&quot; title=&quot;1.栈的理解&quot;&gt;&lt;/a&gt;1.栈的理解&lt;/h4&gt;&lt;p&gt;栈是一种只允许从一端插入或者删除数据的结构，就比如你向弹匣装子弹，只能在头部装，在打枪的时候，也是在头部的子
      
    
    </summary>
    
      <category term="数据结构" scheme="http://sergiojune.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="栈" scheme="http://sergiojune.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>两栈共享空间的实现</title>
    <link href="http://sergiojune.com/2018/10/10/%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://sergiojune.com/2018/10/10/两栈共享空间的实现/</id>
    <published>2018-10-10T10:18:22.442Z</published>
    <updated>2018-10-10T10:37:52.608Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-两栈共享存储空间"><a href="#1-两栈共享存储空间" class="headerlink" title="1. 两栈共享存储空间"></a>1. 两栈共享存储空间</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>使用两个栈来对相同类型的数据来进行存储，就是有个顶部和尾部。</p><p>若只是使用一个栈来使用的话，事先确定栈的容量是非常重要的，因为当容量小了，就需要不断扩大容量，或者容量大了，就会浪费一段存储空间，这都是很麻烦的。但是使用两个栈就可以做到最大限度地利用事先开辟的存储空间。</p><p>当两个栈需要操作相反的关系的时候就可以考虑这个，就比如总有人赚钱和赔钱，那就一边负责增加元素，另一边负责删除元素。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>两栈可以理解为一个长度为 n 的线性表从任意位置切开成两段空间，这样子就会有数组的首尾端都是两个栈的栈底。</p><p>左边的栈为空的时候，就是栈顶为 -1(栈顶的元素位置)，右边的栈为空的时候就是栈顶元素为 n 的时候。</p><p>所以当左边栈满的时候，就是栈顶为 n-1，而右边栈为空就是栈顶为 n，而右边栈满的时候就是栈顶为 0，左边栈为空就是栈顶为 -1。所以当两个碰面的时候，也就是两个栈满的时候，就是两个栈顶的位置相差一的时候，即 leftTop + 1 = rightTop。</p><p>理解上面这个就好实现了，栈需要记录左右两边的栈顶的位置，所以栈的结构需要改变，需要有栈初始化两个栈的容量的总量，还必须声明左右两边栈顶的位置。 </p><h5 id="两个方法实现"><a href="#两个方法实现" class="headerlink" title="两个方法实现"></a>两个方法实现</h5><ol><li>push()：这个需要加入一个栈号参数来判断需要插入那个栈，同时插入时需要判断栈是否满</li><li>pop()：也需要加一个栈号参数来判断删除哪边栈的元素，删除时需要判断栈是否为空。</li></ol><h4 id="2-代码部分"><a href="#2-代码部分" class="headerlink" title="2.代码部分"></a>2.代码部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">// 两栈共享空间</span><br><span class="line">public class DoubleStack &#123;</span><br><span class="line">    int[] arr;</span><br><span class="line">    // 左右分别记录两个栈的的下一个元素需要插入的位置</span><br><span class="line">    int left;</span><br><span class="line">    int right;</span><br><span class="line">    int length;</span><br><span class="line"></span><br><span class="line">    public DoubleStack(int capacity)&#123;</span><br><span class="line">        arr = new int[capacity];</span><br><span class="line">        left = 0;</span><br><span class="line">        right = capacity - 1;</span><br><span class="line">        length = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DoubleStack()&#123;</span><br><span class="line">        this(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return length == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int length()&#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int e, int stackSide)&#123;</span><br><span class="line">        if(left == right + 1)</span><br><span class="line">            throw new IllegalArgumentException(&quot;栈已满，入栈失败&quot;);</span><br><span class="line"></span><br><span class="line">        // 1 代表左边的栈， 2 代表右边的栈</span><br><span class="line">        if(stackSide == 1)&#123;</span><br><span class="line">            arr[left] = e;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (stackSide == 2)&#123;</span><br><span class="line">            arr[right] = e;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            throw new IllegalArgumentException(&quot;stackSide 错误&quot;);</span><br><span class="line">        length ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int pop(int stackSide)&#123;</span><br><span class="line">        if(stackSide == 1)&#123;</span><br><span class="line">            if(left == 0)</span><br><span class="line">                throw new IllegalArgumentException(&quot;出栈失败，左栈为空&quot;);</span><br><span class="line">            int e = arr[left];</span><br><span class="line">            length --;</span><br><span class="line">            left --;</span><br><span class="line">            return e;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(stackSide == 2)&#123;</span><br><span class="line">            if(right == arr.length - 1)</span><br><span class="line">                throw new IllegalArgumentException(&quot;出栈失败，右栈为空&quot;);</span><br><span class="line">            int e = arr[right];</span><br><span class="line">            length --;</span><br><span class="line">            right ++;</span><br><span class="line">            return e;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            throw new IllegalArgumentException(&quot;出栈失败，栈不存在&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        res.append(String.format(&quot;capacith: %d, length: %d\n&quot;, arr.length, length()));</span><br><span class="line">        res.append(&quot;DoubleStack: left tail [&quot;);</span><br><span class="line">        for(int i = 0; i &lt; left; i++)&#123;</span><br><span class="line">            res.append(arr[i]);</span><br><span class="line">            if(i != left - 1)</span><br><span class="line">                res.append(&quot;, &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(&quot;] top  &quot;);</span><br><span class="line"></span><br><span class="line">        res.append(&quot;right top [&quot;);</span><br><span class="line">        for(int i = right + 1; i &lt; arr.length; i++)&#123;</span><br><span class="line">            res.append(arr[i]);</span><br><span class="line">            if(i != arr.length - 1)</span><br><span class="line">                res.append(&quot;, &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(&quot;] tail&quot;);</span><br><span class="line"></span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-两栈共享存储空间&quot;&gt;&lt;a href=&quot;#1-两栈共享存储空间&quot; class=&quot;headerlink&quot; title=&quot;1. 两栈共享存储空间&quot;&gt;&lt;/a&gt;1. 两栈共享存储空间&lt;/h4&gt;&lt;h5 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;header
      
    
    </summary>
    
      <category term="数据结构" scheme="http://sergiojune.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="栈" scheme="http://sergiojune.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>使用单链表进行冒泡排序</title>
    <link href="http://sergiojune.com/2018/10/09/%E4%BD%BF%E7%94%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://sergiojune.com/2018/10/09/使用单链表进行冒泡排序/</id>
    <published>2018-10-09T12:16:59.498Z</published>
    <updated>2018-10-09T12:18:24.252Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是冒泡排序"><a href="#1-什么是冒泡排序" class="headerlink" title="1.什么是冒泡排序"></a>1.什么是冒泡排序</h4><p><br><br>下面这个是百度百科的解释：</p><blockquote><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。<br>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p></blockquote><p>按我的理解就是将相邻的两个元素进行比较，不符合要求的就进行交换位置，交换之后就继续进行下一个的元素的比较，比较一圈之后，最大或者最小的元素就会出现在末端。<br><img src="http://oz39yfeyy.bkt.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt="冒泡排序"></p><p>由上图就可以看出，每每相邻就比较，就像一个个泡泡冒起来，我就是这样理解冒泡排序的。</p><h4 id="2-链表的冒泡排序思路"><a href="#2-链表的冒泡排序思路" class="headerlink" title="2.链表的冒泡排序思路"></a>2.链表的冒泡排序思路</h4><p><br></p><h5 id="1-先讨论下不加虚拟头的情况"><a href="#1-先讨论下不加虚拟头的情况" class="headerlink" title="1)先讨论下不加虚拟头的情况"></a>1)先讨论下不加虚拟头的情况</h5><p>在不加虚拟头时候，我们就需要单独讨论当前节点是不是在链表头部，如果是头部的时候，就需要单独创建一个节点来暂时保存头节点，然后就进行交换<br><img src="http://oz39yfeyy.bkt.clouddn.com/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%97%A0%E8%99%9A%E6%8B%9F%E5%A4%B4.png" alt="无虚拟头交换第一步"></p><p>在交换之后，这时就可以创建两个引用，分别指向头节点和头节点的下一个节点。</p><p>然后通过使用该两个节点的下一个节点就行比较，上面的这两个引用只是为了方便比较和记录。</p><p><img src="http://oz39yfeyy.bkt.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9C%89%E8%99%9A%E6%8B%9F%E5%A4%B4.png" alt="去掉头节点后"></p><p>前面的两个节点在第一次进行比较时，符合位置要求，所以向下移一个位置，第二次比较时就需要进行交换位置了，如上图所示，步骤就不多说了，上面都有。</p><p>交换位置记得顺序不能改变，变了就会造成引用混乱。</p><p>在交换后这时两个节点也可以在上图看出，所以我们只需要移动当前节点即可(currentNode)，然后进行下一次比较。</p><h4 id="2）接着说带虚拟头的"><a href="#2）接着说带虚拟头的" class="headerlink" title="2）接着说带虚拟头的"></a>2）接着说带虚拟头的</h4><p>如果带了虚拟头了，就比上面少了一步，因为不需要进行判断头节点了，这个时候头节点变成了虚拟的，不需要管的了，步骤就和上面的第二步一样。</p><h5 id="比较完了，那什么时候停止呢"><a href="#比较完了，那什么时候停止呢" class="headerlink" title="比较完了，那什么时候停止呢?"></a>比较完了，那什么时候停止呢?</h5><p>因为有时候无法轻易得出链表的长度，这时我引进了一个整型变量，负责记录一次冒泡排序后的交换次数，如果交换次数大于 0，说明链表还需要进行比较，反之就可以直接跳出循环了。</p><h4 id="3-代码展示"><a href="#3-代码展示" class="headerlink" title="3.代码展示"></a>3.代码展示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 链表的冒泡排序</span><br><span class="line">public Node sort(Node head)&#123;</span><br><span class="line">    // 链表没有元素或者只有一个元素</span><br><span class="line">    if(head == null || head.next == null)</span><br><span class="line">        return head;</span><br><span class="line"></span><br><span class="line">    // 创建一个虚拟头结点，便于节点交换，这样子就不需要单独考虑头结点</span><br><span class="line">    Node dummyHead = new Node(head, -1);</span><br><span class="line"></span><br><span class="line">    int num = 0;  // 记录交换次数</span><br><span class="line">    while( true)&#123;</span><br><span class="line">        // 用两个变量分别记录当前节点和下一节点</span><br><span class="line">        // 然后再用他们的下一节点进行比较</span><br><span class="line">        Node currentNode = dummyHead;</span><br><span class="line">        Node nextNode = dummyHead.next;</span><br><span class="line">        // 跳出条件为下一个节点不存在</span><br><span class="line">        while(nextNode.next != null)&#123;</span><br><span class="line">            // 需要进行交换</span><br><span class="line">            if(currentNode.next.data &gt; nextNode.next.data)&#123;</span><br><span class="line">                // 这个有点难说，需要自己画图</span><br><span class="line">                currentNode.next = nextNode.next;</span><br><span class="line">                nextNode.next = currentNode.next.next;</span><br><span class="line">                currentNode.next.next = nextNode;</span><br><span class="line">                currentNode = currentNode.next;</span><br><span class="line">                num ++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                currentNode = currentNode.next;</span><br><span class="line">                nextNode = nextNode.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">        // 判断是否进行交换</span><br><span class="line">        if(num == 0)  // 等于 0 说明没有进行交换</span><br><span class="line">            break;</span><br><span class="line">        else</span><br><span class="line">            num = 0;  // 归 0 下次再进行交换</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h4><p><br></p><ul><li>时间复杂度 O(n^2)：假设最坏情况，比较到最后两个元素还需要进行交换位置，这时外圈循环就是 n - 1 次了，内层永远都是比较到最后一个元素，就是 n。所以时间复杂度为 O(n^2)。就是 n 的平方</li><li>空间复杂度 O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-什么是冒泡排序&quot;&gt;&lt;a href=&quot;#1-什么是冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1.什么是冒泡排序&quot;&gt;&lt;/a&gt;1.什么是冒泡排序&lt;/h4&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;下面这个是百度百科的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="数据结构" scheme="http://sergiojune.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="单链表 冒泡排序" scheme="http://sergiojune.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之单链表的基本方法实现</title>
    <link href="http://sergiojune.com/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://sergiojune.com/2018/10/06/数据结构之单链表的基本方法实现/</id>
    <published>2018-10-06T08:21:14.978Z</published>
    <updated>2018-10-06T08:21:28.566Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-链表的定义"><a href="#1-链表的定义" class="headerlink" title="1.链表的定义"></a>1.链表的定义</h4><p><br><br>与数组有很大的区别，链表不用去申请一段连续的空间，而且他的存储是不连续的，可以真正地做到动态长度。在链表中，不但需要记录该元素的值，还需要记录下一个元素的地址。</p><p>数组在使用时需要申请一段连续空间，当内存不足时就会申请失败，使用链表就可以避免这个问题，不需要进行申请一段连续的内存空间，可以进行动态申请，用到的时候才需要申请。</p><h4 id="2-什么时候用链表"><a href="#2-什么时候用链表" class="headerlink" title="2.什么时候用链表"></a>2.什么时候用链表</h4><p>当需要对数据进行大量的删除插入操作的时候，就可以选择使用链表，这两个操作对于链表来说他的时间复杂度可以说是 O(1)。严格意义来说还是 O(n)。因为进行插入数据的时候，还是需要通过遍历来找到插入的位置，但是这里不需要进行数据迁移，将数据插入即可。如下图所示：</p><p><img src="http://oz39yfeyy.bkt.clouddn.com/%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5.png" alt="链表插入"></p><p>可以看到，找到位置后，修改其下一个指向元素指向即可，但是需要注意的是，两个指向的改变顺序不能变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n.next = node.next;</span><br><span class="line">node.next = n;</span><br></pre></td></tr></table></figure><p>变了之后就会使新插入的元素指向自己，这就会产生引用混乱了。</p><p>删除元素也是同理。</p><h4 id="3-加入虚拟头结点的作用"><a href="#3-加入虚拟头结点的作用" class="headerlink" title="3.加入虚拟头结点的作用"></a>3.加入虚拟头结点的作用</h4><p><br><br>在对链表进行插入和删除等操作时，都必须考虑头结点是否为空的情况，因为不为空才会有下一个节点的存在。</p><p>在加上了虚拟头结点，就可以节省这一步的操作，无论链表是否为空，都必定存在链表，只不过这个链表只有虚拟头结点的时候长度还是为 0， 这个时候就可以判断该节点的下一个节点是否为空即可。</p><p>注意：虚拟头结点不算入长度</p><h4 id="4-需要的结构以及实现的基本方法"><a href="#4-需要的结构以及实现的基本方法" class="headerlink" title="4.需要的结构以及实现的基本方法"></a>4.需要的结构以及实现的基本方法</h4><p><br><br>结构:<br>    需要一个内部类，里面存储元素的值以及下一个元素的引用<br>    同时在初始化链表的时候需要声明长度为 0 ，并且实现虚拟头结点</p><p>方法：</p><ul><li>int getLength()：获取链表长度</li><li>boolean isEmpty()：判断链表是否为空</li><li>void add(int index, int data)：向链表的 index 位置加入元素</li><li>int get(int index)：获取 index 位置的元素</li><li>void set(int index, int data)：修改 index 位置的元素</li><li>boolean contains(int data)：判断该元素是否在链表中</li><li>int remove(int index)：移除链表中 index 位置的元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">// 单链表</span><br><span class="line">public class SinglyLinkedlist &#123;</span><br><span class="line">    // 节点结构</span><br><span class="line">    class Node&#123;</span><br><span class="line">        int data;</span><br><span class="line">        Node next;  // 记录下一节点</span><br><span class="line"></span><br><span class="line">        public Node(Node node, int data)&#123;</span><br><span class="line">            this.next = node;</span><br><span class="line">            this.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">        public Node(int data)&#123;</span><br><span class="line">            this(null, data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String toString()&#123;</span><br><span class="line">            return data + &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int length;</span><br><span class="line">    Node head;  // 虚拟头结点</span><br><span class="line"></span><br><span class="line">    public SinglyLinkedlist()&#123;</span><br><span class="line">        this.length = 0;</span><br><span class="line">        // 初始化头结点</span><br><span class="line">        head = new Node(null, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取长度</span><br><span class="line">    public int getLength()&#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断链表是否为空</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return length == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 往链表头添加元素</span><br><span class="line">    public void addFirst(int data)&#123;</span><br><span class="line">        // 因为第一个节点是不存储数据的，所以不需要判断第一个节点是否为空</span><br><span class="line">//        Node node = new Node(data);</span><br><span class="line">//        node.next = head.next;</span><br><span class="line">//        head.next = node;</span><br><span class="line">//        length ++;</span><br><span class="line"></span><br><span class="line">        add(0, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 往链尾添加元素</span><br><span class="line">    public void addLast(int data)&#123;</span><br><span class="line"></span><br><span class="line">//        Node node = head;</span><br><span class="line">//        for (;node.next != null; node = node.next) &#123;</span><br><span class="line">//</span><br><span class="line">//        &#125;</span><br><span class="line">//        node.next = new Node(data);</span><br><span class="line">//        length ++;</span><br><span class="line"></span><br><span class="line">        add(length, data);  // 直接调用自己的函数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 往链表任意位置插入元素</span><br><span class="line">    public void add(int index, int data)&#123;</span><br><span class="line">        if(index &lt; 0 || index &gt;length)</span><br><span class="line">            throw new IllegalArgumentException(&quot;插入元素失败，index 非法&quot;);</span><br><span class="line"></span><br><span class="line">        Node node = head;</span><br><span class="line">        int i = 0;</span><br><span class="line">        // 找到插入元素位置的前一个节点即可</span><br><span class="line">        while(i &lt; index)&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        Node n = new Node(data);</span><br><span class="line">        n.next = node.next;</span><br><span class="line">        node.next = n;</span><br><span class="line"></span><br><span class="line">        length ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取链表index的位置</span><br><span class="line">    public int get(int index)&#123;</span><br><span class="line">        if(index &lt; 0 || index &gt;= length)</span><br><span class="line">            throw new IllegalArgumentException(&quot;获取元素失败，index 非法&quot;);</span><br><span class="line">        Node node = head;</span><br><span class="line">        for(int i = 0; i &lt; index; i++)&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return node.next.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取首位元素</span><br><span class="line">    public int getFirst()&#123;</span><br><span class="line">        return get(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取尾部元素</span><br><span class="line">    public int getLast()&#123;</span><br><span class="line">        return get(length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修改链表中的 index 位置的元素</span><br><span class="line">    public void set(int index, int data)&#123;</span><br><span class="line">        if(index &lt; 0 || index &gt;= length)</span><br><span class="line">            throw new IllegalArgumentException(&quot;插入元素失败，index 非法&quot;);</span><br><span class="line">        Node node = head.next;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(i &lt; index)&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        node.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查询链表是否包含这个元素</span><br><span class="line">    public boolean contains(int data)&#123;</span><br><span class="line">        Node node = head.next;</span><br><span class="line">        while(node != null)&#123;</span><br><span class="line">            if(node.data == data)</span><br><span class="line">                return true;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除指定节点</span><br><span class="line">    public int remove(int index)&#123;</span><br><span class="line">        if(index &lt; 0 || index &gt;= length)</span><br><span class="line">            throw new IllegalArgumentException(&quot;删除元素失败，index 非法&quot;);</span><br><span class="line">        Node node = head;</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node n = node.next;  // 准备被删除的元素</span><br><span class="line">        node.next = n.next;</span><br><span class="line">        int data = n.data;</span><br><span class="line">        n.next = null;  // 释放</span><br><span class="line">        length--;  // 必须记得这个</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除头结点</span><br><span class="line">    public int removeFirst()&#123;</span><br><span class="line">        return remove(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除尾节点</span><br><span class="line">    public int removeLast()&#123;</span><br><span class="line">        return remove(length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        Node node = head.next;</span><br><span class="line">        res.append(String.format(&quot;length: %d\n&quot;, length));</span><br><span class="line">        res.append(&quot;LinkedList: &quot;);</span><br><span class="line">        for(int i = 0; i &lt; length; i++)&#123;</span><br><span class="line">            res.append(node.data);</span><br><span class="line">            res.append(&quot; --&gt; &quot;);</span><br><span class="line">            node =  node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(&quot;NULL&quot;);</span><br><span class="line"></span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="5-以后补充"><a href="#5-以后补充" class="headerlink" title="5.以后补充"></a>5.以后补充</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-链表的定义&quot;&gt;&lt;a href=&quot;#1-链表的定义&quot; class=&quot;headerlink&quot; title=&quot;1.链表的定义&quot;&gt;&lt;/a&gt;1.链表的定义&lt;/h4&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;与数组有很大的区别，链表不用去申请一段连续的空间，而且他的存储是不连续的，可以真正地
      
    
    </summary>
    
      <category term="数据结构" scheme="http://sergiojune.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="单链表" scheme="http://sergiojune.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之数组的基本方法实现</title>
    <link href="http://sergiojune.com/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://sergiojune.com/2018/10/06/数据结构之数组的基本方法实现/</id>
    <published>2018-10-06T02:33:54.656Z</published>
    <updated>2018-10-06T02:34:58.565Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-数组介绍"><a href="#1-数组介绍" class="headerlink" title="1.数组介绍"></a>1.数组介绍</h4><p><br><br>数组就是内存中一段连续的存储空间，并且存储的内容必须数据类型相同。<br>数组坐标从 0 开始，因为是在 c 语言中的计算数组的地址位置时，这样计算的：</p><blockquote><p>arr[i]_address = base_addrress + i * sizeof(data)</p></blockquote><p>如果从 1 开始，cpu 就会多执行了一次减法计算，对人类也不友好</p><blockquote><p>arr[i]_address = base_addrress + (i-1) * sizeof(data)</p></blockquote><p>其他语言也是和向 c 学习的，因为这样可以减轻大家的学习成本（我猜的）</p><h4 id="2-什么时候用数组"><a href="#2-什么时候用数组" class="headerlink" title="2.什么时候用数组"></a>2.什么时候用数组</h4><p><br><br>当一组数据需要经常对数据进行查询和改变元素的值，这个时候就可以使用数组，因为数组是一段连续的存储空间，这就有利于根据地址来查找某一个位置的元素或者进行改变，这两个操作都是 O(1)。</p><p>比如英雄联盟中的商店，那个装备位置都是固定的，你就可以根据地址快速找出装备来进行查看，这个就可以用数组来实现。</p><p>但是你的装备栏就不可以了，因为需要经常回家更新装备，需要进行大量的插入和删除，这个时候再用数组来存储的话，就显得效率很低了，因为这两个的时间复杂度都是 O(n)。但是另一种数据结构就非常合适，就是链表。这个以后再说。</p><p>数组的插入和删除操作也是可以通过适当改变也可以让其时间复杂度变小点的。比如在对数组进行删除时，我们可以先把需要删除的元素记录下来暂不处理，当数组的容量装不下来的时候，这个时候再触发真正的删除操作，这样子就可以大大地减少对数据的迁移以及申请内存空间的操作。</p><p>还有插入的时候我们也可以先把需要插入位置的元素(初始元素)先把其放进数组尾部，然后把元素插入该位置，然后记录下这些元素的位置，当数组容量满的时候，再进行一次数据迁移，这样也可大大减少数据迁移工作。</p><p>这两个可以说是通过空间换时间吧。</p><h4 id="3-基本方法"><a href="#3-基本方法" class="headerlink" title="3. 基本方法"></a>3. 基本方法</h4><p><br><br>数组结构：1.数组声明  2.数组当前长度</p><p>方法：</p><ul><li>boolean isEmpty()：判断数组是否为空，时间复杂度为 O(1)</li><li>int get(int index)：根据 index 获取元素，时间复杂度为 O(1)</li><li>set(int index, int e)：改变 index 位置的元素，时间复杂度为 O(1)</li><li>int find(int e)：查找该元素是否存在在数组，存在就返回该元素的位置，反之返回 -1，时间复杂度为 O(1)</li><li>void add(int index, int e)：添加元素，时间复杂度为 O(n)</li><li>int remove(int index)：删除元素，时间复杂度为 O(n)</li></ul><h4 id="4-方法的实现"><a href="#4-方法的实现" class="headerlink" title="4.方法的实现"></a>4.方法的实现</h4><p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class ArrayList &#123;</span><br><span class="line">    int length;  // 当前数组的长度</span><br><span class="line">    int[] array;  // 暂时存储int类型</span><br><span class="line"></span><br><span class="line">    // 初始化数组</span><br><span class="line">    public ArrayList(int capacity)&#123;</span><br><span class="line">        this.array = new int[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    //空参数的就默认容量为10</span><br><span class="line">    public ArrayList()&#123;</span><br><span class="line">        this(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取当前数组长度</span><br><span class="line">    public int getLength()&#123;</span><br><span class="line">        return this.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断数组是否为空</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return this.length == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据index获取线性表的值</span><br><span class="line">    public int get(int index)&#123;</span><br><span class="line">        if(index &lt; 0 || index &gt;= length)&#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;index 不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 改变 index 位置的元素</span><br><span class="line">    public int set(int index, int e)&#123;</span><br><span class="line">        if(index &lt; 0 || index &gt;= length)&#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;改变元素失败，index 不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int k = array[index];</span><br><span class="line">        array[index] = e;</span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据所给的值查找该元素在数组的位置，不存在就返回 -1</span><br><span class="line">    public int find(int e)&#123;</span><br><span class="line">//        for(int i = 0; i &lt; length; i++)&#123;</span><br><span class="line">//            if(array[i] == e)</span><br><span class="line">//                return i;</span><br><span class="line">//        &#125;</span><br><span class="line">//        return -1;</span><br><span class="line"></span><br><span class="line">        // 需要先判断数组是否为空</span><br><span class="line">        if(length == 0)</span><br><span class="line">            return -1;</span><br><span class="line"></span><br><span class="line">        if(array[length - 1] == e)</span><br><span class="line">            return length -1;</span><br><span class="line">        int key = array[length - 1];  // 记录最后一个元素</span><br><span class="line">        array[length - 1] = e;  // 当哨兵</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(array[i] != e) // 这个比上面的方法少了个判断，当数组过大时，效率就会有差别</span><br><span class="line">            i++;</span><br><span class="line">        // 再把最后一个元素复原</span><br><span class="line">        array[length - 1] = key;</span><br><span class="line">        if(i == length - 1)</span><br><span class="line">            return -1;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 向index位置插入元素</span><br><span class="line">    public void add(int index, int e)&#123;</span><br><span class="line">        if(index &gt; length || index &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;添加元素失败，index非法&quot;);</span><br><span class="line"></span><br><span class="line">        if(length &gt;= array.length)</span><br><span class="line">            throw new IllegalArgumentException(&quot;添加元素失败，容量已达到最大&quot;);</span><br><span class="line"></span><br><span class="line">        for(int i = length; i &gt; index; i--)&#123;</span><br><span class="line">            array[i] = array[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        array[index] = e;</span><br><span class="line">        length ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除当前数组的index位置的元素</span><br><span class="line">    public int remove(int index)&#123;</span><br><span class="line">        if(index &gt; length || index &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;删除元素失败，index非法&quot;);</span><br><span class="line">        int e = array[index];</span><br><span class="line">        for(int i = index; i &lt; length - 1; i++)&#123;</span><br><span class="line">            array[i] = array[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        length --;</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        res.append(String.format(&quot;capacity: %d, length: %d\n&quot;, array.length, length));</span><br><span class="line">        res.append(&quot;Array: [ &quot;);</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            res.append(array[i]);</span><br><span class="line">            if(i == length - 1)</span><br><span class="line">                res.append(&apos;]&apos;);</span><br><span class="line">            else</span><br><span class="line">                res.append(&quot;, &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p> <br></p><h4 id="5-以后再补充别的扩展"><a href="#5-以后再补充别的扩展" class="headerlink" title="5. 以后再补充别的扩展"></a>5. 以后再补充别的扩展</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-数组介绍&quot;&gt;&lt;a href=&quot;#1-数组介绍&quot; class=&quot;headerlink&quot; title=&quot;1.数组介绍&quot;&gt;&lt;/a&gt;1.数组介绍&lt;/h4&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;数组就是内存中一段连续的存储空间，并且存储的内容必须数据类型相同。&lt;br&gt;数组坐标从 0 开
      
    
    </summary>
    
      <category term="数据结构" scheme="http://sergiojune.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数组" scheme="http://sergiojune.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构的时间复杂度分析</title>
    <link href="http://sergiojune.com/2018/10/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>http://sergiojune.com/2018/10/05/数据结构的时间复杂度分析/</id>
    <published>2018-10-05T02:20:27.506Z</published>
    <updated>2018-10-05T02:20:39.099Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-算法定义"><a href="#1-算法定义" class="headerlink" title="1.算法定义"></a>1.算法定义</h4><p><br><br>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p><p>通俗来说，数据结构是指一组数据的存储结构，而算法就是操作数据的一组方法。就好比图书馆藏书籍，为了方便查找，通常都会分门别类地整理放在特定的地方，这些书籍的结构就是存储结构。当我们需要查找书的时候，我们是要按类别来查找呢，还是一本一本地找？或者按书本编号来查找？这个就是对数据存储的操作。所以说这些查找的方法都是算法。</p><h5 id="算法的五个基本特性："><a href="#算法的五个基本特性：" class="headerlink" title="算法的五个基本特性："></a>算法的五个基本特性：</h5><p><br></p><ol><li>输入：每个算法都有零个或多个输入</li><li>输出：算法一定会有输出，要不这个算法毫无意义</li><li>有穷性：指算法在执行有限的步骤后能自动结束，不会陷入死循环。并且每个步骤都需要在可接受的时间内完成</li><li>确定性：算法的每个步骤都需要有明确的意义</li><li>可行性：算法的每一步都能够通过执行有限次数完成<br><br><h5 id="对算法设计的五个要求"><a href="#对算法设计的五个要求" class="headerlink" title="对算法设计的五个要求"></a>对算法设计的五个要求</h5><br></li><li>正确性：指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案</li><li>可读性：设计的算法便于阅读、理解和交流</li><li>健壮性：当输入非法数据时，算法也能做出相应的处理，而不是产生异常或者有莫名其妙的结果</li><li>时间效率高：也就是等等下面详细说的时间复杂度要小。</li><li>存储量低：就是空间复杂度，追求时间少的同时，也尽可能追求需要消耗的内存少点。</li></ol><p><br></p><h4 id="2-度量算法的执行时间"><a href="#2-度量算法的执行时间" class="headerlink" title="2.度量算法的执行时间"></a>2.度量算法的执行时间</h4><p><br></p><h5 id="事后统计方法"><a href="#事后统计方法" class="headerlink" title="事后统计方法"></a>事后统计方法</h5><p><br><br>就是使用大量的测试数据进行对算法的测试，进而对不同的算法运行时间进行比较来确定算法效率的高低。</p><p>这样子并不好，一是测试结果非常依赖于测试环境，二是测试结果需要大规模的数据进行测试，非常浪费人力物力。非常不推荐使用这种方法来进行度量。</p><h5 id="大-O-复杂度的表示法"><a href="#大-O-复杂度的表示法" class="headerlink" title="大 O 复杂度的表示法"></a>大 O 复杂度的表示法</h5><p><br><br>通过对算法步骤实现代码的运行次数来度量算法的执行时间，随着代码的运行次数越少，其执行时间必定会越少，就比如下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># include&lt;stdio.h&gt;</span><br><span class="line"># include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int sum = 0;</span><br><span class="line">int i;</span><br><span class="line">for(i = 0; i &lt;= 100; i++)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;sum=%d\n&quot;, sum);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oz39yfeyy.bkt.clouddn.com/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png" alt="复杂度分析"></p><p>如上图所示，这段代码的时间复杂度就是 2n+ 5，当 n 很大时，这个公式中的低阶、常量和系数都是可以忽略不计的，也就是说上面程序的复杂度就是 n，记作 O(n)。</p><h4 id="3-时间复杂度的分析"><a href="#3-时间复杂度的分析" class="headerlink" title="3.时间复杂度的分析"></a>3.时间复杂度的分析</h4><h5 id="只关注循环执行次数最多的一段代码"><a href="#只关注循环执行次数最多的一段代码" class="headerlink" title="只关注循环执行次数最多的一段代码"></a>只关注循环执行次数最多的一段代码</h5><p>因为大 O 这种复杂度分析只关注最大阶的量级，会忽略掉低阶、常量和系数，所以在对时间复杂度的分析时，可以直接对循环次数最多的代码进行分析即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">while(i &lt; 100)</span><br><span class="line">&#123;</span><br><span class="line">i = i * 2;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p><br><br>根据方法我们只看循环部分即可，这个的分析方法可以先设 x 为代码执行步数，当 i 大于等于 100 时会退出循环，就是有 2 的 x 次方 等于 n(100)，可以推得 x = log2n ,最后去掉常量，一般写成 O(logn).<br><br></p><h5 id="加法法则"><a href="#加法法则" class="headerlink" title="加法法则"></a>加法法则</h5><p><br><br>就是总复杂度等于量级最大得那段代码的复杂度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int i, j;</span><br><span class="line">int sum = 0;</span><br><span class="line">for(i = 0; i &lt; 100; i++)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(j = 0; j &lt; 1000; j++)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; 1000; i++)</span><br><span class="line">&#123;</span><br><span class="line">    for(j = 0; j &lt; 1000; j++)</span><br><span class="line">    &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p><br><br>这个前面的两个循环都不如第三个嵌套循环量级大，就可以直接分析第三个循环的时间复杂度即可，所以该时间复杂度就是 O(n2)<br><br></p><h5 id="3-乘法法则"><a href="#3-乘法法则" class="headerlink" title="3.乘法法则"></a>3.乘法法则</h5><p><br><br>嵌套代码的时间复杂度等于嵌套内外代码复杂度的乘积。</p><p>嵌套可以是循环嵌套，也可以是函数内部嵌套另一个函数。</p><p>他们的时间复杂度都是外部嵌套的时间复杂度 乘于 内部嵌套代码的时间复杂度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int f1(int n)</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line">int sum = 0;</span><br><span class="line">for(; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum + f2(i);</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int f2(int n)</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line">int sum = 0;</span><br><span class="line">while(i &lt; n);</span><br><span class="line">sum = sum * 2;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 f1 函数的时间复杂度就是等于 f1的循环代码的时间复杂度 乘于 f2 的时间复杂度， 也就是 O(n*logn)</p><p><br></p><h4 id="4-常见的时间复杂度"><a href="#4-常见的时间复杂度" class="headerlink" title="4.常见的时间复杂度"></a>4.常见的时间复杂度</h4><p><br></p><ul><li>常数阶O(1), </li><li>对数阶O(log n), </li><li>3线性阶O(n), </li><li>线性对数阶O(n log n), </li><li>平方阶O(n^2)， </li><li>立方阶O(n^3) </li><li>k次方阶O(n^K), </li><li>指数阶O(2^n)。<br><br><br>消耗时间从小到大排序为： O(1) &lt; (log n) &lt; (n) &lt; O(n log n) &lt; (n^2) &lt; O(n^3) &lt; O(n^3) &lt; O(n^K) &lt; O(2^n)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-算法定义&quot;&gt;&lt;a href=&quot;#1-算法定义&quot; class=&quot;headerlink&quot; title=&quot;1.算法定义&quot;&gt;&lt;/a&gt;1.算法定义&lt;/h4&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个
      
    
    </summary>
    
      <category term="数据结构" scheme="http://sergiojune.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="时间复杂度" scheme="http://sergiojune.com/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>c语言提高第一天总结</title>
    <link href="http://sergiojune.com/2018/09/29/c%E8%AF%AD%E8%A8%80%E6%8F%90%E9%AB%98%E7%AC%AC%E4%B8%80%E5%A4%A9%E6%80%BB%E7%BB%93/"/>
    <id>http://sergiojune.com/2018/09/29/c语言提高第一天总结/</id>
    <published>2018-09-28T16:32:18.034Z</published>
    <updated>2018-09-28T16:32:22.224Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>c语言中的数组作为形参时编译器都会把它当成指针处理，所以在对数组进行操作的时候，通常还需要再加个一个形参，那就是<strong>数组长度</strong>，因为数组的结束没有标志，需要程序员自己进行判断。<br><br></p><a id="more"></a><p>2.引入数据类型是为了更容易地表达现实生活中的人和事，<strong>数据类型本质就是固定大小的一段内存空间</strong>，常见的数据类型的所占字节大小如下：</p><ul><li>int: 4 字节</li><li>char: 1 字节</li><li>float: 4 字节</li><li>double: 8字节</li><li>long: 4 字节</li><li>指针: 4 字节<br><br></li></ul></li><li><p>当有一个数组 <strong>b</strong>，打印 <strong>b+1</strong> 和 <strong>&amp;b+1</strong> 是不同的，这是因为他们的数据类型不一样，前者代表的是这个数组的首个元素的地址，后者表达的是数组的最后一个元素的地址，所以 <strong>&amp;b</strong> 表达的是整块数组的地址<br><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int b[] = &#123;1,2,5,3,8,9,4&#125;;</span><br><span class="line">printf(&quot;b = %d, b + 1 = %d, &amp;b = %d, &amp; b + 1 = %d\n&quot;, b, b+1, &amp;b, &amp;b+1);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 结果是：</span><br><span class="line">b = 7338172, b + 1 = 7338176, &amp;b = 7338172, &amp; b + 1 = 7338200</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="4"><li>return 不是把内存块的字节 return 出来，而是把内存快的首地址返回。</li></ol><p><br></p><ol start="5"><li>判断栈是开口向上还是向下，利用栈后进先出的特性<strong>可以通过先后定义两个变量继而打印他们的地址来知道开口的方向，先存的变量的地址小就说明开口是向上的，反之就是向下的</strong>，有一个需要注意的 是，存放数组时，他的每一个元素的地址都是递增，也就是说都是开口向上的，这个说明不了栈的开口！<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># include&lt;stdio.h&gt;</span><br><span class="line"># include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">// 两个变量先后被压进栈，通过判断地址可以判断栈的开口</span><br><span class="line">int a;</span><br><span class="line">int b;</span><br><span class="line">printf(&quot;&amp;a=%d, &amp;b=%d\n&quot;, &amp;a, &amp;b);  // 通过debug方式编译是开口向下的，通过release编译则是向下的</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&amp;a=13630336, &amp;b=13630340  // 可以看到开口是向上的</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="6"><li><p>函数调用模型： 一般都是先将该函数的地址压入栈，然后就是将其参数压入栈，接着才是将其代码压入栈，如果该函数调用了别的函数，执行到了，就会将该函数的运行状态压入栈，然后再将被调用的函数地址压入栈，接着重复上述过程。<br><br></p></li><li><p>c语言中，内存区一般分为四个区，分别是：</p><ul><li>栈：存放的是局部变量，程序运行结束之后就会被操作系统自动释放</li><li>堆： 存放的是动态创建的变量，不能自动释放，需要程序员手动释放</li><li>全局区： 又名静态区，存放的是全局变量以及静态变量，还存放一些常量，比如字符串常量和其他常量，该区域还是等待程序结束后操作系统释放内存，但和栈不同的是，<strong>他里的所被分配的内存可以被之前的函数给调用</strong>。</li><li>代码区： 存放我们所写的代码。</li></ul></li></ol><p><br></p><p>第一天就这么多啦，每天进步一点点就足够！<br><br><br>今天还学到一个鼓励自己的方法： <strong>每当自己学不进去的时候，就去知乎看看，你会发现，原来你自己什么都不会！毕竟知乎里的都是大牛。然后你就会马上滚回来学习了</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;c语言中的数组作为形参时编译器都会把它当成指针处理，所以在对数组进行操作的时候，通常还需要再加个一个形参，那就是&lt;strong&gt;数组长度&lt;/strong&gt;，因为数组的结束没有标志，需要程序员自己进行判断。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础" scheme="http://sergiojune.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="c" scheme="http://sergiojune.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>随便说点事情</title>
    <link href="http://sergiojune.com/2018/09/28/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E7%82%B9%E4%BA%8B%E6%83%85/"/>
    <id>http://sergiojune.com/2018/09/28/随便说点事情/</id>
    <published>2018-09-28T02:10:43.981Z</published>
    <updated>2018-09-28T05:18:40.170Z</updated>
    
    <content type="html"><![CDATA[<h5 id="随便说点事情吧。"><a href="#随便说点事情吧。" class="headerlink" title="随便说点事情吧。"></a>随便说点事情吧。</h5><p>最近在学习c语言，算是对以前知识的复习，但是学习过程中并不是很想学，总是想着python，有时真的很怀疑自己是不是真的选择错了，好好的python转去学习c/c++。可能因为我自己有个gh吧，毕竟涉及到钱的问题就是很困扰，还是解脱不了对钱的束缚。</p><p>不过我是真的想学好底层基础，就是看着太无聊了，不肯花时间去慢慢学习，想把这些写下来，看看能不能让自己静下心来。</p><p>现在算是体会到了什么是孤独吧，一个人学习，一个人敲代码，很多人都没有共同语言，迷茫了又不敢去打扰别人，只好跑来自己的博客去倾诉。对啊，我还有自己的博客，你想说什么都可以，他都可以倾听！所以以后有事没事都来这里发发牢骚了，毕竟这是我的自留地。</p><p>今天终于把游戏给卸载了，自从我开了个gh之后为了钱好久没有认真学习了，我现在还在打算是否要继续发下去，转载文章也是需要精力，也不想随便转载而浪费了读者的阅读时间，这样子对不起读者，更对不起我自己。是时候做个权衡了。</p><ul><li>以后一周发两篇即可，其他的不管了，随意而为，发技术或者自己感想都可以吧。</li></ul><p>我这个博客需要更新了，好久之前就想更新了，一直没更新，还是自己的行动力不足啊，或者也是对自己的恐惧感不足。想起辉哥的一句话：任何行动力不足的都源自于你不够恐惧。足够恐惧，你就会行动。现在意识到自己处于一个很危险的处境也是很难的，很多时候自己都太过于骄傲了，但是自己其实很渣，这个坏毛病总是改不了。希望以后能改掉吧。</p><p>还有自己当初在家里想的那些目标，好像都没有实现到，一个月还剩两天就过了，目标一个都没有实现，不知道问题出在哪里了。自己买的书总是在第一周保持新鲜感，再过几天的话就越来越不想看了，这也是个大问题，得解决！可是自己没有办法，想了想，可能是自己没有那个「延迟满足感」吧，总想着做一件事，今天做完明天就能有效果，殊不知，效果这个东西只会在你不经意间才能体现出来，它并不会特意表现出来给你看的。还是马云说得好「今天很残酷，明天更残酷，后天会很美好，但大多数人倒在了明天晚上」。可能我就是那个大多数人吧，但我不甘心，我是要成为那小部分人的，我道理都挺那么多了，那我就得过好这一生，管理好自己。</p><p>这个博客从明天开始更新了，需要把我的笔记的都放上去了。</p><p>但是都是随意写的，自己看得懂就好，尽量也让大家都看得懂。</p><p>以上内容发自一个对自己游戏感到失望，对人生感到迷茫的渣渣，希望说出来能过得好点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;随便说点事情吧。&quot;&gt;&lt;a href=&quot;#随便说点事情吧。&quot; class=&quot;headerlink&quot; title=&quot;随便说点事情吧。&quot;&gt;&lt;/a&gt;随便说点事情吧。&lt;/h5&gt;&lt;p&gt;最近在学习c语言，算是对以前知识的复习，但是学习过程中并不是很想学，总是想着python，有
      
    
    </summary>
    
      <category term="个人随想" scheme="http://sergiojune.com/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="胡思乱想" scheme="http://sergiojune.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建的博客提交文章本地预览成功但github没有显示解决方法</title>
    <link href="http://sergiojune.com/2018/08/07/hexo%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4%E6%96%87%E7%AB%A0%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88%E6%88%90%E5%8A%9F%E4%BD%86github%E6%B2%A1%E6%9C%89%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://sergiojune.com/2018/08/07/hexo搭建的博客提交文章本地预览成功但github没有显示解决方法/</id>
    <published>2018-08-07T00:43:42.059Z</published>
    <updated>2018-08-26T11:25:30.039Z</updated>
    
    <content type="html"><![CDATA[<section class="96edit" label="Powered by bj.96weixin.com" style="font-size:16px;"><p>记录自己博客的一个坑！</p><p><br></p><p>前几天我写了文章，想发布在博客上，<strong>谁知道在提交上去，只可以在本地预览，却不可以在github上看到，</strong>而且github上也没有提交文章的记录。这个坑我百度了很久也没有找到，直到问到人，<strong>说需要升级git，然后升级了。</strong>果然，成功提交了！！！</p><p><br></p><p><br><a id="more"></a><br>升级git是直接在重新下载个git把原来的覆盖掉就可以了。</p><p><br></p><p>升级完成之后记得再提交一次，比如：</p><ul class=" list-paddingleft-2" style="list-style-type: disc; margin: 0px; padding: 0px 0px 0px 30px;"><li><p>hexo clean</p></li><li><p>hexo g</p></li><li><p>hexo d</p></li></ul><p>这样就可以了，如果还是不可以，可以选择清除下cookie及历史记录。</p><p><br></p><p><br></p><p>我完成了上面的之后，文章算是提交上去了，但是，我的主题没有了，<img src="http://pic.96weixin.com/upload/image2/vip/881679/1803/1803139675.png" title="1803139675.png" _src="http://pic.96weixin.com/upload/image2/vip/881679/1803/1803139675.png" alt=""></p><p>很悲催，没想到一坑还比一坑高，所以还是接着百度，看到了可能是我的<strong>github的仓库名字</strong>和我的hexo博客里的配置<strong>_config.yml</strong>​文件中的url名字不一样导致的<img src="http://pic.96weixin.com/upload/image2/vip/881679/1803/1803133008.png" title="1803133008.png" _src="http://pic.96weixin.com/upload/image2/vip/881679/1803/1803133008.png" alt=""></p><p><br></p><p>试了一下，果真是可以了。这个坑是前面那个坑乱改东西留下的，不过解决了，就好！！</p><p><br></p><p><br></p><p>生活不止眼前的bug，还有乐趣和斗志！</p><p><br></p><p><br></p><p><br></p><p><br></p></section>]]></content>
    
    <summary type="html">
    
      &lt;section class=&quot;96edit&quot; label=&quot;Powered by bj.96weixin.com&quot; style=&quot;font-size:16px;&quot;&gt;&lt;p&gt;记录自己博客的一个坑！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;前几天我写了文章，想发布在博客上，&lt;strong&gt;谁知道在提交上去，只可以在本地预览，却不可以在github上看到，&lt;/strong&gt;而且github上也没有提交文章的记录。这个坑我百度了很久也没有找到，直到问到人，&lt;strong&gt;说需要升级git，然后升级了。&lt;/strong&gt;果然，成功提交了！！！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="blog" scheme="http://sergiojune.com/categories/blog/"/>
    
    
      <category term="坑" scheme="http://sergiojune.com/tags/%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>谈谈今晚以及在跑步时的一些随想</title>
    <link href="http://sergiojune.com/2018/05/24/%E8%B0%88%E8%B0%88%E4%BB%8A%E6%99%9A%E4%BB%A5%E5%8F%8A%E5%9C%A8%E8%B7%91%E6%AD%A5%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9A%8F%E6%83%B3/"/>
    <id>http://sergiojune.com/2018/05/24/谈谈今晚以及在跑步时的一些随想/</id>
    <published>2018-05-24T14:11:38.000Z</published>
    <updated>2018-08-06T08:53:50.843Z</updated>
    
    <content type="html"><![CDATA[<p>今天可以算是我的第一次在讲台上分享我的技术，准备了两天左右吧，其实也没那么长，就是做了个ppt而已，由于第一次做，有很多地方都没有做好，比如字体太小了，背景和字体颜色混合了导致看不清字等等此类的问题。如果下次再做的话一定要做得好一点。<br>还有就是我的分享有点垃圾哈，讲的内容自我感觉不是很好，也不知道需要讲什么地方，以后还是多观察下别人怎么分享吧。<br>这次需要表扬自己的是上讲台讲台没有预料中的那么紧张，虽然讲话不是很自如，不过也比以前好多了，希望下次能更进一步吧！加油！</p><h4 id="说说跑步的感想！"><a href="#说说跑步的感想！" class="headerlink" title="说说跑步的感想！"></a>说说跑步的感想！</h4><p>这两星期我经常跑步，跑完步还会做50个俯卧撑，虽然不太标准，不过也好过没有做吧。在跑步时会跑多几圈就会很累，就想放弃，不过我最后还是咬牙就挺着过去了。这两天跑步呢，我就想，追逐梦想就和跑步一样吧。就比如我把梦想都分成很多个小目标，跑步的圈数或者步数就是这些小小的目标。在刚开始的时候，你跑步会很顺利，小目标也是这样子，刚开始的小目标也是很容易就可以实现的。可是当你跑步的步数多了，也就是小目标实现多了，之后的每一步或每一个小目标都会显得举步维艰，这时候就需要你自己的意志力去支持着自己继续跑下去。所以说梦想也需要用自己的一生去实现，后面可能会越来越难，可你每实现的一个小目标都会把很多人甩在身后面，这些人就相当于你在跑步过程中的路人。</p><h4 id="人生是一场永无止尽的跑步！"><a href="#人生是一场永无止尽的跑步！" class="headerlink" title="人生是一场永无止尽的跑步！"></a>人生是一场永无止尽的跑步！</h4><p>还有这几天会经常不知道干嘛，然而还有很多事情没做，先把这些事列下来吧！<br>线性代数课程补上</p><ul><li>离散数学课程及作业补上</li><li>高等数学课程补上</li><li>scrapy的学习</li><li>马蜂窝网站的全站抓取</li><li>淘宝商品抓取</li><li>亚马逊模拟登陆</li><li>爬虫面试题</li><li>看 图解http</li><li>看 网络是怎样连接</li><li>了解下各种排序</li></ul><p>不列出来都不知道有这么多事情没做，以后觉得没事的时候可以找这些事情做了。</p><p>写完，睡觉！晚安！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天可以算是我的第一次在讲台上分享我的技术，准备了两天左右吧，其实也没那么长，就是做了个ppt而已，由于第一次做，有很多地方都没有做好，比如字体太小了，背景和字体颜色混合了导致看不清字等等此类的问题。如果下次再做的话一定要做得好一点。&lt;br&gt;还有就是我的分享有点垃圾哈，讲的
      
    
    </summary>
    
      <category term="个人随想" scheme="http://sergiojune.com/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>2017年终总结</title>
    <link href="http://sergiojune.com/2017/12/31/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://sergiojune.com/2017/12/31/2017年终总结/</id>
    <published>2017-12-31T14:11:38.000Z</published>
    <updated>2018-08-06T08:53:50.818Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2017的最后一天了，对于2017，是我至今为止最重要的一年，在这一年中经历了人生的第一场高考，很高兴，这也是最后一场。而在下半年，我也进入了大学，虽然大学不是理想中的大学，但是我也很高兴，因为终于可以不再像高中那样了，在这里我可以学习我想要学的东西！</p><h1 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h1><p>那时我还在准备高考，每天沉迷于题海之中，那段在一中的时间，是我高中过得最充实的时间，每天早上六点起床，晚上奋斗到差不多一点才睡。<br>但是高三一年的勤奋拉近不了我在高中挥霍了两年的时间所带来的与别人的距离，所以在每次模拟试下来之后都在想，为啥前两年不学多一点呢？这样子在高三就不会这么辛苦，也就不会有这么大的坑让给高三的一年来填。但是我也不会后悔，因为在那两年里，我学会了踢球，懂得了人生有太多的意外，比如我在高二那年的足球班赛，我也认识了一大堆志同道合的人。所以说，对自己走过的路不曾后悔。<br>在这半年，我度过了第一个百日誓师，还记得那天康亚华校长的谈话，还记得我们跑步的激情，还记得那天之后对未来的憧憬。。。</p><pre><code>百日誓师，壮观！！！</code></pre><p><img src="http://oz39yfeyy.bkt.clouddn.com/mmexport1514702564565.jpg" alt="百日誓师"></p><pre><code>下面是我们班在百日誓师的照片</code></pre><p><img src="http://oz39yfeyy.bkt.clouddn.com/null-6ef188b3db149be1.jpg" alt="高三十四班"></p><p>最后放张我们学校的照片吧，离开后才发现学校是真的美！<br><img src="http://oz39yfeyy.bkt.clouddn.com/null-2e688bf1463c76c7.jpg" alt="吴川一中"><br><strong> 最后六月份，走上了考场，离开了学校，最终的结果也对得起我在高三奋斗的一年！ </strong></p><h1 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h1><p>下半年我走进了大学，大学虽然没有想象的大和好，但这始终会是我在余下四年继续坚持我奋斗的地方，所以我也爱上了这个地方。<br><strong> 看！ </strong><br><img src="http://oz39yfeyy.bkt.clouddn.com/mmexport1511785817443.jpg" alt="我的大学"><br><img src="http://oz39yfeyy.bkt.clouddn.com/mmexport1511785833297.jpg" alt="我的大学"><br>我的大学还是很美的。<br>还有我的班，每个都很帅很漂亮，有木有！！！<br><img src="http://oz39yfeyy.bkt.clouddn.com/mmexport1510329287628.jpg" alt="软件工程4班"><br><img src="http://oz39yfeyy.bkt.clouddn.com/IMG_20170921_202907.jpg.JPG" alt="软件工程4班"><br>在这大学半年里，我学了很多编程知识，比如c语言，python，html+css+javascript和java，学了这么多，都是因为去尝试吧，因为我暂时不知道我要往哪个方向发展，现在我知道了，我准备往爬虫，分析大数据方向，或许还有人工智能，还有就是以python为主的前端<br>在学了这么多，自己模仿了两个网页，也做了一个简单的查看新闻app，总之还没有深入，准备下一年深入学习。<br>不过在学习学校的课程是失败的，很多课都没有认真学习，英语也没有学好，觉得蛮遗憾的，浪费了这么多时间。<br>还有，我也根据了网上的教程自己搭建了一个属于自己的博客，也挺不错的。<br>而在自己博客定的小目标也没有完成多少，可能要完成的东西太多了，所以也没有完成，下一次就知道应该定多少了，嘻嘻！<br>我在最后的一个月还参加了一个打卡活动，里面的早起和坚持锻炼我基本上算是坚持下来了，算是比较欣慰了。</p><p><strong><em> 引用知识星球人里一段话 </em></strong></p><blockquote><p>人生那么长，做着枯燥而无意义的工作，每时每刻都是煎熬。  人生那么短，如果每一步成长都是令人激动的，那你一定不会说:”后悔”。</p></blockquote><blockquote><p>尝试，不断试错，不断碰壁，不断重来，你会发现人生有那么多的可能。会发现世界上有那么美丽的事情让我们满心欢喜。</p></blockquote><blockquote><p>献给现在迷茫，未来成功的你。</p></blockquote><h3 id="不忘初心，方得始终。"><a href="#不忘初心，方得始终。" class="headerlink" title="不忘初心，方得始终。"></a>不忘初心，方得始终。</h3><h3 id="2018，我来了！！！"><a href="#2018，我来了！！！" class="headerlink" title="2018，我来了！！！"></a>2018，我来了！！！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是2017的最后一天了，对于2017，是我至今为止最重要的一年，在这一年中经历了人生的第一场高考，很高兴，这也是最后一场。而在下半年，我也进入了大学，虽然大学不是理想中的大学，但是我也很高兴，因为终于可以不再像高中那样了，在这里我可以学习我想要学的东西！&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
      <category term="总结" scheme="http://sergiojune.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="hard" scheme="http://sergiojune.com/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://sergiojune.com/2017/11/05/helloworld/"/>
    <id>http://sergiojune.com/2017/11/05/helloworld/</id>
    <published>2017-11-04T23:28:16.000Z</published>
    <updated>2018-08-06T08:53:50.831Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29414561&auto=0&height=66"></iframe><p><strong>昨天博客基本搭建完毕，</strong></p><p>搞到10点多，</p><p>只能说身心疲惫，但是觉得都值。</p><p>终于有了自己的后花园，以后发表什么还不是我说了算吗？  哈哈</p><p>这篇文章想了很久，几个小时，总想不出要写什么，</p><p>因为觉得自己拥有了博客，</p><p>总得发个东西装逼一下，</p><p>但细想一下，又没什么好写，</p><p>想一下文采真的烂，不过没事，谁都是这样子过来的，</p><p><strong>以后会变好的！</strong></p><p>最后分享一首美国诗！</p><blockquote><p>纽约时间比加州时间早三个小时，</p></blockquote><blockquote><p>New York is 3 hours ahead of California,</p></blockquote><blockquote><p>但加州时间并没有变慢。</p></blockquote><blockquote><p>but it does not make California slow.</p></blockquote><blockquote><p>有人22岁就毕业了，</p></blockquote><blockquote><p>Someone graduated at the age of 22,</p></blockquote><blockquote><p>但等了五年才找到好的工作！</p></blockquote><blockquote><p>but waited 5 years before securing a good job!</p></blockquote><blockquote><p>有人25岁就当上CEO，</p></blockquote><blockquote><p>Someone became a CEO at 25,</p></blockquote><blockquote><p>却在50岁去世。</p></blockquote><blockquote><p>and died at 50.</p></blockquote><blockquote><p>也有人迟到50岁才当上CEO，</p></blockquote><blockquote><p>While another became a CEO at 50,</p></blockquote><blockquote><p>然后活到90岁。</p></blockquote><blockquote><p>and lived to 90 years.</p></blockquote><blockquote><p>有人依然单身，</p></blockquote><blockquote><p>Someone is still single,</p></blockquote><blockquote><p>同时也有人已婚。</p></blockquote><blockquote><p>while someone else got married.</p></blockquote><blockquote><p>奥巴马55岁就退休，</p></blockquote><blockquote><p>Obama retires at 55,</p></blockquote><blockquote><p>川普70岁才开始当总统。</p></blockquote><blockquote><p>but Trump starts at 70.</p></blockquote><blockquote><p>世上每个人本来就有自己的发展时区。</p></blockquote><blockquote><p>Absolutely everyone in this world works based on their &gt;Time Zone.</p></blockquote><blockquote><p>身边有些人看似走在你前面，</p></blockquote><blockquote><p>People around you might seem to go ahead of you,</p></blockquote><blockquote><p>也有人看似走在你后面。</p></blockquote><blockquote><p>some might seem to be behind you.</p></blockquote><blockquote><p>但其实每个人在自己的时区有自己的步程。</p></blockquote><blockquote><p>But everyone is running their own RACE, in their own&gt;TIME.</p></blockquote><blockquote><p>不用嫉妒或嘲笑他们。</p></blockquote><blockquote><p>Don’t envy them or mock them.</p></blockquote><blockquote><p>他们都在自己的时区里，你也是！</p></blockquote><blockquote><p>They are in their TIME ZONE, and you are in yours!</p></blockquote><blockquote><p>生命就是等待正确的行动时机。</p></blockquote><blockquote><p>Life is about waiting for the right moment to act.</p></blockquote><blockquote><p>所以，放轻松。</p></blockquote><blockquote><p>So, RELAX.</p></blockquote><blockquote><p>你没有落后。</p></blockquote><blockquote><p>You’re not LATE.</p></blockquote><blockquote><p>你没有领先。</p></blockquote><blockquote><p>You’re not EARLY.</p></blockquote><blockquote><p>在命运为你安排的属于自己的时区里，一切都准时。</p></blockquote><blockquote><p>You are very much ON TIME, and in your TIME ZONE Destiny set up for you.</p></blockquote><p><strong>我的全栈之路开启了！！！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
      <category term="android" scheme="http://sergiojune.com/categories/android/"/>
    
    
      <category term="run" scheme="http://sergiojune.com/tags/run/"/>
    
  </entry>
  
</feed>
