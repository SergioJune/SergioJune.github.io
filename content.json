[{"title":"数据结构之单链表的基本方法实现","date":"2018-10-06T08:21:14.978Z","path":"2018/10/06/数据结构之单链表的基本方法实现/","text":"1.链表的定义与数组有很大的区别，链表不用去申请一段连续的空间，而且他的存储是不连续的，可以真正地做到动态长度。在链表中，不但需要记录该元素的值，还需要记录下一个元素的地址。 数组在使用时需要申请一段连续空间，当内存不足时就会申请失败，使用链表就可以避免这个问题，不需要进行申请一段连续的内存空间，可以进行动态申请，用到的时候才需要申请。 2.什么时候用链表当需要对数据进行大量的删除插入操作的时候，就可以选择使用链表，这两个操作对于链表来说他的时间复杂度可以说是 O(1)。严格意义来说还是 O(n)。因为进行插入数据的时候，还是需要通过遍历来找到插入的位置，但是这里不需要进行数据迁移，将数据插入即可。如下图所示： 可以看到，找到位置后，修改其下一个指向元素指向即可，但是需要注意的是，两个指向的改变顺序不能变 12n.next = node.next;node.next = n; 变了之后就会使新插入的元素指向自己，这就会产生引用混乱了。 删除元素也是同理。 3.加入虚拟头结点的作用在对链表进行插入和删除等操作时，都必须考虑头结点是否为空的情况，因为不为空才会有下一个节点的存在。 在加上了虚拟头结点，就可以节省这一步的操作，无论链表是否为空，都必定存在链表，只不过这个链表只有虚拟头结点的时候长度还是为 0， 这个时候就可以判断该节点的下一个节点是否为空即可。 注意：虚拟头结点不算入长度 4.需要的结构以及实现的基本方法结构: 需要一个内部类，里面存储元素的值以及下一个元素的引用 同时在初始化链表的时候需要声明长度为 0 ，并且实现虚拟头结点 方法： int getLength()：获取链表长度 boolean isEmpty()：判断链表是否为空 void add(int index, int data)：向链表的 index 位置加入元素 int get(int index)：获取 index 位置的元素 void set(int index, int data)：修改 index 位置的元素 boolean contains(int data)：判断该元素是否在链表中 int remove(int index)：移除链表中 index 位置的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171import java.util.Random;// 单链表public class SinglyLinkedlist &#123; // 节点结构 class Node&#123; int data; Node next; // 记录下一节点 public Node(Node node, int data)&#123; this.next = node; this.data = data; &#125; public Node(int data)&#123; this(null, data); &#125; public String toString()&#123; return data + &quot;&quot;; &#125; &#125; int length; Node head; // 虚拟头结点 public SinglyLinkedlist()&#123; this.length = 0; // 初始化头结点 head = new Node(null, 0); &#125; // 获取长度 public int getLength()&#123; return length; &#125; // 判断链表是否为空 public boolean isEmpty()&#123; return length == 0; &#125; // 往链表头添加元素 public void addFirst(int data)&#123; // 因为第一个节点是不存储数据的，所以不需要判断第一个节点是否为空// Node node = new Node(data);// node.next = head.next;// head.next = node;// length ++; add(0, data); &#125; // 往链尾添加元素 public void addLast(int data)&#123;// Node node = head;// for (;node.next != null; node = node.next) &#123;//// &#125;// node.next = new Node(data);// length ++; add(length, data); // 直接调用自己的函数 &#125; // 往链表任意位置插入元素 public void add(int index, int data)&#123; if(index &lt; 0 || index &gt;length) throw new IllegalArgumentException(&quot;插入元素失败，index 非法&quot;); Node node = head; int i = 0; // 找到插入元素位置的前一个节点即可 while(i &lt; index)&#123; node = node.next; i ++; &#125; Node n = new Node(data); n.next = node.next; node.next = n; length ++; &#125; // 获取链表index的位置 public int get(int index)&#123; if(index &lt; 0 || index &gt;= length) throw new IllegalArgumentException(&quot;获取元素失败，index 非法&quot;); Node node = head; for(int i = 0; i &lt; index; i++)&#123; node = node.next; &#125; return node.next.data; &#125; // 获取首位元素 public int getFirst()&#123; return get(0); &#125; // 获取尾部元素 public int getLast()&#123; return get(length - 1); &#125; // 修改链表中的 index 位置的元素 public void set(int index, int data)&#123; if(index &lt; 0 || index &gt;= length) throw new IllegalArgumentException(&quot;插入元素失败，index 非法&quot;); Node node = head.next; int i = 0; while(i &lt; index)&#123; node = node.next; i++; &#125; node.data = data; &#125; // 查询链表是否包含这个元素 public boolean contains(int data)&#123; Node node = head.next; while(node != null)&#123; if(node.data == data) return true; node = node.next; &#125; return false; &#125; // 删除指定节点 public int remove(int index)&#123; if(index &lt; 0 || index &gt;= length) throw new IllegalArgumentException(&quot;删除元素失败，index 非法&quot;); Node node = head; for (int i = 0; i &lt; index; i++) &#123; node = node.next; &#125; Node n = node.next; // 准备被删除的元素 node.next = n.next; int data = n.data; n.next = null; // 释放 length--; // 必须记得这个 return data; &#125; // 删除头结点 public int removeFirst()&#123; return remove(0); &#125; // 删除尾节点 public int removeLast()&#123; return remove(length - 1); &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); Node node = head.next; res.append(String.format(&quot;length: %d\\n&quot;, length)); res.append(&quot;LinkedList: &quot;); for(int i = 0; i &lt; length; i++)&#123; res.append(node.data); res.append(&quot; --&gt; &quot;); node = node.next; &#125; res.append(&quot;NULL&quot;); return res.toString(); &#125; 5.以后补充","tags":[{"name":"单链表","slug":"单链表","permalink":"http://sergiojune.com/tags/单链表/"}]},{"title":"数据结构之数组的基本方法实现","date":"2018-10-06T02:33:54.656Z","path":"2018/10/06/数据结构之数组的基本方法实现/","text":"1.数组介绍数组就是内存中一段连续的存储空间，并且存储的内容必须数据类型相同。数组坐标从 0 开始，因为是在 c 语言中的计算数组的地址位置时，这样计算的： arr[i]_address = base_addrress + i * sizeof(data) 如果从 1 开始，cpu 就会多执行了一次减法计算，对人类也不友好 arr[i]_address = base_addrress + (i-1) * sizeof(data) 其他语言也是和向 c 学习的，因为这样可以减轻大家的学习成本（我猜的） 2.什么时候用数组当一组数据需要经常对数据进行查询和改变元素的值，这个时候就可以使用数组，因为数组是一段连续的存储空间，这就有利于根据地址来查找某一个位置的元素或者进行改变，这两个操作都是 O(1)。 比如英雄联盟中的商店，那个装备位置都是固定的，你就可以根据地址快速找出装备来进行查看，这个就可以用数组来实现。 但是你的装备栏就不可以了，因为需要经常回家更新装备，需要进行大量的插入和删除，这个时候再用数组来存储的话，就显得效率很低了，因为这两个的时间复杂度都是 O(n)。但是另一种数据结构就非常合适，就是链表。这个以后再说。 数组的插入和删除操作也是可以通过适当改变也可以让其时间复杂度变小点的。比如在对数组进行删除时，我们可以先把需要删除的元素记录下来暂不处理，当数组的容量装不下来的时候，这个时候再触发真正的删除操作，这样子就可以大大地减少对数据的迁移以及申请内存空间的操作。 还有插入的时候我们也可以先把需要插入位置的元素(初始元素)先把其放进数组尾部，然后把元素插入该位置，然后记录下这些元素的位置，当数组容量满的时候，再进行一次数据迁移，这样也可大大减少数据迁移工作。 这两个可以说是通过空间换时间吧。 3. 基本方法数组结构：1.数组声明 2.数组当前长度 方法： boolean isEmpty()：判断数组是否为空，时间复杂度为 O(1) int get(int index)：根据 index 获取元素，时间复杂度为 O(1) set(int index, int e)：改变 index 位置的元素，时间复杂度为 O(1) int find(int e)：查找该元素是否存在在数组，存在就返回该元素的位置，反之返回 -1，时间复杂度为 O(1) void add(int index, int e)：添加元素，时间复杂度为 O(n) int remove(int index)：删除元素，时间复杂度为 O(n) 4.方法的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import java.util.Random;public class ArrayList &#123; int length; // 当前数组的长度 int[] array; // 暂时存储int类型 // 初始化数组 public ArrayList(int capacity)&#123; this.array = new int[capacity]; &#125; //空参数的就默认容量为10 public ArrayList()&#123; this(10); &#125; // 获取当前数组长度 public int getLength()&#123; return this.length; &#125; // 判断数组是否为空 public boolean isEmpty()&#123; return this.length == 0; &#125; // 根据index获取线性表的值 public int get(int index)&#123; if(index &lt; 0 || index &gt;= length)&#123; throw new IllegalArgumentException(&quot;index 不存在&quot;); &#125; return array[index]; &#125; // 改变 index 位置的元素 public int set(int index, int e)&#123; if(index &lt; 0 || index &gt;= length)&#123; throw new IllegalArgumentException(&quot;改变元素失败，index 不存在&quot;); &#125; int k = array[index]; array[index] = e; return k; &#125; // 根据所给的值查找该元素在数组的位置，不存在就返回 -1 public int find(int e)&#123;// for(int i = 0; i &lt; length; i++)&#123;// if(array[i] == e)// return i;// &#125;// return -1; // 需要先判断数组是否为空 if(length == 0) return -1; if(array[length - 1] == e) return length -1; int key = array[length - 1]; // 记录最后一个元素 array[length - 1] = e; // 当哨兵 int i = 0; while(array[i] != e) // 这个比上面的方法少了个判断，当数组过大时，效率就会有差别 i++; // 再把最后一个元素复原 array[length - 1] = key; if(i == length - 1) return -1; return i; &#125; // 向index位置插入元素 public void add(int index, int e)&#123; if(index &gt; length || index &lt; 0) throw new IllegalArgumentException(&quot;添加元素失败，index非法&quot;); if(length &gt;= array.length) throw new IllegalArgumentException(&quot;添加元素失败，容量已达到最大&quot;); for(int i = length; i &gt; index; i--)&#123; array[i] = array[i - 1]; &#125; array[index] = e; length ++; &#125; // 删除当前数组的index位置的元素 public int remove(int index)&#123; if(index &gt; length || index &lt; 0) throw new IllegalArgumentException(&quot;删除元素失败，index非法&quot;); int e = array[index]; for(int i = index; i &lt; length - 1; i++)&#123; array[i] = array[i + 1]; &#125; length --; return e; &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append(String.format(&quot;capacity: %d, length: %d\\n&quot;, array.length, length)); res.append(&quot;Array: [ &quot;); for (int i = 0; i &lt; length; i++) &#123; res.append(array[i]); if(i == length - 1) res.append(&apos;]&apos;); else res.append(&quot;, &quot;); &#125; return res.toString(); &#125; 5. 以后再补充别的扩展","tags":[{"name":"数组","slug":"数组","permalink":"http://sergiojune.com/tags/数组/"}]},{"title":"数据结构的时间复杂度分析","date":"2018-10-05T02:20:27.506Z","path":"2018/10/05/数据结构的时间复杂度分析/","text":"1.算法定义算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 通俗来说，数据结构是指一组数据的存储结构，而算法就是操作数据的一组方法。就好比图书馆藏书籍，为了方便查找，通常都会分门别类地整理放在特定的地方，这些书籍的结构就是存储结构。当我们需要查找书的时候，我们是要按类别来查找呢，还是一本一本地找？或者按书本编号来查找？这个就是对数据存储的操作。所以说这些查找的方法都是算法。 算法的五个基本特性： 输入：每个算法都有零个或多个输入 输出：算法一定会有输出，要不这个算法毫无意义 有穷性：指算法在执行有限的步骤后能自动结束，不会陷入死循环。并且每个步骤都需要在可接受的时间内完成 确定性：算法的每个步骤都需要有明确的意义 可行性：算法的每一步都能够通过执行有限次数完成对算法设计的五个要求 正确性：指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案 可读性：设计的算法便于阅读、理解和交流 健壮性：当输入非法数据时，算法也能做出相应的处理，而不是产生异常或者有莫名其妙的结果 时间效率高：也就是等等下面详细说的时间复杂度要小。 存储量低：就是空间复杂度，追求时间少的同时，也尽可能追求需要消耗的内存少点。 2.度量算法的执行时间 事后统计方法就是使用大量的测试数据进行对算法的测试，进而对不同的算法运行时间进行比较来确定算法效率的高低。 这样子并不好，一是测试结果非常依赖于测试环境，二是测试结果需要大规模的数据进行测试，非常浪费人力物力。非常不推荐使用这种方法来进行度量。 大 O 复杂度的表示法通过对算法步骤实现代码的运行次数来度量算法的执行时间，随着代码的运行次数越少，其执行时间必定会越少，就比如下面这个例子： 123456789101112131415# include&lt;stdio.h&gt;# include&lt;stdlib.h&gt;int main(void)&#123; int sum = 0; int i; for(i = 0; i &lt;= 100; i++) &#123; sum = sum + i; &#125; printf(&quot;sum=%d\\n&quot;, sum); system(&quot;pause&quot;); return 0;&#125; 如上图所示，这段代码的时间复杂度就是 2n+ 5，当 n 很大时，这个公式中的低阶、常量和系数都是可以忽略不计的，也就是说上面程序的复杂度就是 n，记作 O(n)。 3.时间复杂度的分析只关注循环执行次数最多的一段代码因为大 O 这种复杂度分析只关注最大阶的量级，会忽略掉低阶、常量和系数，所以在对时间复杂度的分析时，可以直接对循环次数最多的代码进行分析即可。 1234567int i = 1;while(i &lt; 100)&#123; i = i * 2;&#125;system(&quot;pause&quot;);return 0; 根据方法我们只看循环部分即可，这个的分析方法可以先设 x 为代码执行步数，当 i 大于等于 100 时会退出循环，就是有 2 的 x 次方 等于 n(100)，可以推得 x = log2n ,最后去掉常量，一般写成 O(logn). 加法法则就是总复杂度等于量级最大得那段代码的复杂度 123456789101112131415161718192021int i, j;int sum = 0;for(i = 0; i &lt; 100; i++)&#123; sum = sum + i;&#125;for(j = 0; j &lt; 1000; j++)&#123; sum = sum + j;&#125;for(i = 0; i &lt; 1000; i++)&#123; for(j = 0; j &lt; 1000; j++) &#123; sum = sum + i; &#125;&#125;system(&quot;pause&quot;);return 0; 这个前面的两个循环都不如第三个嵌套循环量级大，就可以直接分析第三个循环的时间复杂度即可，所以该时间复杂度就是 O(n2) 3.乘法法则嵌套代码的时间复杂度等于嵌套内外代码复杂度的乘积。 嵌套可以是循环嵌套，也可以是函数内部嵌套另一个函数。 他们的时间复杂度都是外部嵌套的时间复杂度 乘于 内部嵌套代码的时间复杂度。 12345678910111213141516171819int f1(int n)&#123; int i = 0; int sum = 0; for(; i &lt; n; i ++) &#123; sum = sum + f2(i); &#125; return sum;&#125;int f2(int n)&#123; int i = 0; int sum = 0; while(i &lt; n); sum = sum * 2; return sum;&#125; 上面的 f1 函数的时间复杂度就是等于 f1的循环代码的时间复杂度 乘于 f2 的时间复杂度， 也就是 O(n*logn) 4.常见的时间复杂度 常数阶O(1), 对数阶O(log n), 3线性阶O(n), 线性对数阶O(n log n), 平方阶O(n^2)， 立方阶O(n^3) k次方阶O(n^K), 指数阶O(2^n)。消耗时间从小到大排序为： O(1) &lt; (log n) &lt; (n) &lt; O(n log n) &lt; (n^2) &lt; O(n^3) &lt; O(n^3) &lt; O(n^K) &lt; O(2^n)","tags":[{"name":"时间复杂度","slug":"时间复杂度","permalink":"http://sergiojune.com/tags/时间复杂度/"}]},{"title":"数据结构之线性栈的理解及实现","date":"2018-10-04T15:55:03.088Z","path":"2018/10/04/数据结构之线性栈的理解及实现/","text":"1.栈的理解栈是一种只允许从一端插入或者删除数据的结构，就比如你向弹匣装子弹，只能在头部装，在打枪的时候，也是在头部的子弹先发射出去，简单地说就是后进先出。 栈的插入操作叫做进栈，也称压栈、入栈。栈的删除操作叫做出栈，也叫弹栈。 2.栈的应用我们在浏览网页的时候，都会有个后退的按钮，这个就是用栈来实现的，还有就是大部分软件的可撤销操作，也都是用栈实现的。 3.栈的结构需要实现的方法结构： 需要声明栈的容量以及当前栈的长度（就是下一个元素插入的位置或者当前栈顶的元素位置） 方法： InitStack(*s): 初始化操作，建立一个空栈。 DestoryStack(*s): 若栈存在，就销毁栈 ClearStaack(*s): 清空栈 StackEmpty(*s): 判断栈是否为空，若为空，返回true GetTop(*s, e): 若栈顶存在，就用 e 来返回栈定元素 Push(*s， e): 向栈顶插入元素，并用 e 返回栈顶元素 Pop(*s, e): 若站栈顶存在，就删除栈顶元素并赋值给 e 返回 StackLength(): 获取栈的长度 4.用 c 语言实现线性栈有空补上 5. 用 Java 语言实现线性栈有空补上 6. 两栈共享存储空间定义使用两个栈来对相同类型的数据来进行存储，就是有个顶部和尾部。 若只是使用一个栈来使用的话，事先确定栈的容量是非常重要的，因为当容量小了，就需要不断扩大容量，或者容量大了，就会浪费一段存储空间，这都是很麻烦的。但是使用两个栈就可以做到最大限度地利用事先开辟的存储空间。 当两个栈需要操作相反的关系的时候就可以考虑这个，就比如总有人赚钱和赔钱，那就一边负责增加元素，另一边负责删除元素。 实现两栈可以理解为一个长度为 n 的线性表从任意位置切开成两段空间，这样子就会有数组的首尾端都是两个栈的栈底。 左边的栈为空的时候，就是栈顶为 -1(栈顶的元素位置)，右边的栈为空的时候就是栈顶元素为 n 的时候。 所以当左边栈满的时候，就是栈顶为 n-1，而右边栈为空就是栈顶为 n，而右边栈满的时候就是栈顶为 0，左边栈为空就是栈顶为 -1。所以当两个碰面的时候，也就是两个栈满的时候，就是两个栈顶的位置相差一的时候，即 leftTop + 1 = rightTop。 理解上面这个就好实现了，栈需要记录左右两边的栈顶的位置，所以栈的结构需要改变，需要有栈初始化两个栈的容量的总量，还必须声明左右两边栈顶的位置。 两个方法实现 push()：这个需要加入一个栈号参数来判断需要插入那个栈，同时插入时需要判断栈是否满 pop()：也需要加一个栈号参数来判断删除哪边栈的元素，删除时需要判断栈是否为空。","tags":[{"name":"栈","slug":"栈","permalink":"http://sergiojune.com/tags/栈/"}]},{"title":"c语言提高第一天总结","date":"2018-09-28T16:32:18.034Z","path":"2018/09/29/c语言提高第一天总结/","text":"c语言中的数组作为形参时编译器都会把它当成指针处理，所以在对数组进行操作的时候，通常还需要再加个一个形参，那就是数组长度，因为数组的结束没有标志，需要程序员自己进行判断。 2.引入数据类型是为了更容易地表达现实生活中的人和事，数据类型本质就是固定大小的一段内存空间，常见的数据类型的所占字节大小如下： int: 4 字节 char: 1 字节 float: 4 字节 double: 8字节 long: 4 字节 指针: 4 字节 当有一个数组 b，打印 b+1 和 &amp;b+1 是不同的，这是因为他们的数据类型不一样，前者代表的是这个数组的首个元素的地址，后者表达的是数组的最后一个元素的地址，所以 &amp;b 表达的是整块数组的地址 1234567891011121314# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;int main(void)&#123; int b[] = &#123;1,2,5,3,8,9,4&#125;; printf(&quot;b = %d, b + 1 = %d, &amp;b = %d, &amp; b + 1 = %d\\n&quot;, b, b+1, &amp;b, &amp;b+1); system(&quot;pause&quot;); return 0;&#125;# 结果是：b = 7338172, b + 1 = 7338176, &amp;b = 7338172, &amp; b + 1 = 7338200 return 不是把内存块的字节 return 出来，而是把内存快的首地址返回。 判断栈是开口向上还是向下，利用栈后进先出的特性可以通过先后定义两个变量继而打印他们的地址来知道开口的方向，先存的变量的地址小就说明开口是向上的，反之就是向下的，有一个需要注意的 是，存放数组时，他的每一个元素的地址都是递增，也就是说都是开口向上的，这个说明不了栈的开口！123456789101112131415# include&lt;stdio.h&gt;# include&lt;stdlib.h&gt;int main(void)&#123; // 两个变量先后被压进栈，通过判断地址可以判断栈的开口 int a; int b; printf(&quot;&amp;a=%d, &amp;b=%d\\n&quot;, &amp;a, &amp;b); // 通过debug方式编译是开口向下的，通过release编译则是向下的 system(&quot;pause&quot;); return 0;&#125;结果：&amp;a=13630336, &amp;b=13630340 // 可以看到开口是向上的 函数调用模型： 一般都是先将该函数的地址压入栈，然后就是将其参数压入栈，接着才是将其代码压入栈，如果该函数调用了别的函数，执行到了，就会将该函数的运行状态压入栈，然后再将被调用的函数地址压入栈，接着重复上述过程。 c语言中，内存区一般分为四个区，分别是： 栈：存放的是局部变量，程序运行结束之后就会被操作系统自动释放 堆： 存放的是动态创建的变量，不能自动释放，需要程序员手动释放 全局区： 又名静态区，存放的是全局变量以及静态变量，还存放一些常量，比如字符串常量和其他常量，该区域还是等待程序结束后操作系统释放内存，但和栈不同的是，他里的所被分配的内存可以被之前的函数给调用。 代码区： 存放我们所写的代码。 第一天就这么多啦，每天进步一点点就足够！今天还学到一个鼓励自己的方法： 每当自己学不进去的时候，就去知乎看看，你会发现，原来你自己什么都不会！毕竟知乎里的都是大牛。然后你就会马上滚回来学习了","tags":[{"name":"c","slug":"c","permalink":"http://sergiojune.com/tags/c/"}]},{"title":"随便说点事情","date":"2018-09-28T02:10:43.981Z","path":"2018/09/28/随便说点事情/","text":"随便说点事情吧。最近在学习c语言，算是对以前知识的复习，但是学习过程中并不是很想学，总是想着python，有时真的很怀疑自己是不是真的选择错了，好好的python转去学习c/c++。可能因为我自己有个gh吧，毕竟涉及到钱的问题就是很困扰，还是解脱不了对钱的束缚。 不过我是真的想学好底层基础，就是看着太无聊了，不肯花时间去慢慢学习，想把这些写下来，看看能不能让自己静下心来。 现在算是体会到了什么是孤独吧，一个人学习，一个人敲代码，很多人都没有共同语言，迷茫了又不敢去打扰别人，只好跑来自己的博客去倾诉。对啊，我还有自己的博客，你想说什么都可以，他都可以倾听！所以以后有事没事都来这里发发牢骚了，毕竟这是我的自留地。 今天终于把游戏给卸载了，自从我开了个gh之后为了钱好久没有认真学习了，我现在还在打算是否要继续发下去，转载文章也是需要精力，也不想随便转载而浪费了读者的阅读时间，这样子对不起读者，更对不起我自己。是时候做个权衡了。 以后一周发两篇即可，其他的不管了，随意而为，发技术或者自己感想都可以吧。 我这个博客需要更新了，好久之前就想更新了，一直没更新，还是自己的行动力不足啊，或者也是对自己的恐惧感不足。想起辉哥的一句话：任何行动力不足的都源自于你不够恐惧。足够恐惧，你就会行动。现在意识到自己处于一个很危险的处境也是很难的，很多时候自己都太过于骄傲了，但是自己其实很渣，这个坏毛病总是改不了。希望以后能改掉吧。 还有自己当初在家里想的那些目标，好像都没有实现到，一个月还剩两天就过了，目标一个都没有实现，不知道问题出在哪里了。自己买的书总是在第一周保持新鲜感，再过几天的话就越来越不想看了，这也是个大问题，得解决！可是自己没有办法，想了想，可能是自己没有那个「延迟满足感」吧，总想着做一件事，今天做完明天就能有效果，殊不知，效果这个东西只会在你不经意间才能体现出来，它并不会特意表现出来给你看的。还是马云说得好「今天很残酷，明天更残酷，后天会很美好，但大多数人倒在了明天晚上」。可能我就是那个大多数人吧，但我不甘心，我是要成为那小部分人的，我道理都挺那么多了，那我就得过好这一生，管理好自己。 这个博客从明天开始更新了，需要把我的笔记的都放上去了。 但是都是随意写的，自己看得懂就好，尽量也让大家都看得懂。 以上内容发自一个对自己游戏感到失望，对人生感到迷茫的渣渣，希望说出来能过得好点。","tags":[{"name":"胡思乱想","slug":"胡思乱想","permalink":"http://sergiojune.com/tags/胡思乱想/"}]},{"title":"hexo搭建的博客提交文章本地预览成功但github没有显示解决方法","date":"2018-08-07T00:43:42.059Z","path":"2018/08/07/hexo搭建的博客提交文章本地预览成功但github没有显示解决方法/","text":"记录自己博客的一个坑！前几天我写了文章，想发布在博客上，谁知道在提交上去，只可以在本地预览，却不可以在github上看到，而且github上也没有提交文章的记录。这个坑我百度了很久也没有找到，直到问到人，说需要升级git，然后升级了。果然，成功提交了！！！升级git是直接在重新下载个git把原来的覆盖掉就可以了。升级完成之后记得再提交一次，比如：hexo cleanhexo ghexo d这样就可以了，如果还是不可以，可以选择清除下cookie及历史记录。我完成了上面的之后，文章算是提交上去了，但是，我的主题没有了，很悲催，没想到一坑还比一坑高，所以还是接着百度，看到了可能是我的github的仓库名字和我的hexo博客里的配置_config.yml​文件中的url名字不一样导致的试了一下，果真是可以了。这个坑是前面那个坑乱改东西留下的，不过解决了，就好！！生活不止眼前的bug，还有乐趣和斗志！","tags":[{"name":"坑","slug":"坑","permalink":"http://sergiojune.com/tags/坑/"}]},{"title":"谈谈今晚以及在跑步时的一些随想","date":"2018-05-24T14:11:38.000Z","path":"2018/05/24/谈谈今晚以及在跑步时的一些随想/","text":"今天可以算是我的第一次在讲台上分享我的技术，准备了两天左右吧，其实也没那么长，就是做了个ppt而已，由于第一次做，有很多地方都没有做好，比如字体太小了，背景和字体颜色混合了导致看不清字等等此类的问题。如果下次再做的话一定要做得好一点。还有就是我的分享有点垃圾哈，讲的内容自我感觉不是很好，也不知道需要讲什么地方，以后还是多观察下别人怎么分享吧。这次需要表扬自己的是上讲台讲台没有预料中的那么紧张，虽然讲话不是很自如，不过也比以前好多了，希望下次能更进一步吧！加油！ 说说跑步的感想！这两星期我经常跑步，跑完步还会做50个俯卧撑，虽然不太标准，不过也好过没有做吧。在跑步时会跑多几圈就会很累，就想放弃，不过我最后还是咬牙就挺着过去了。这两天跑步呢，我就想，追逐梦想就和跑步一样吧。就比如我把梦想都分成很多个小目标，跑步的圈数或者步数就是这些小小的目标。在刚开始的时候，你跑步会很顺利，小目标也是这样子，刚开始的小目标也是很容易就可以实现的。可是当你跑步的步数多了，也就是小目标实现多了，之后的每一步或每一个小目标都会显得举步维艰，这时候就需要你自己的意志力去支持着自己继续跑下去。所以说梦想也需要用自己的一生去实现，后面可能会越来越难，可你每实现的一个小目标都会把很多人甩在身后面，这些人就相当于你在跑步过程中的路人。 人生是一场永无止尽的跑步！还有这几天会经常不知道干嘛，然而还有很多事情没做，先把这些事列下来吧！线性代数课程补上 离散数学课程及作业补上 高等数学课程补上 scrapy的学习 马蜂窝网站的全站抓取 淘宝商品抓取 亚马逊模拟登陆 爬虫面试题 看 图解http 看 网络是怎样连接 了解下各种排序 不列出来都不知道有这么多事情没做，以后觉得没事的时候可以找这些事情做了。 写完，睡觉！晚安！","tags":[]},{"title":"2017年终总结","date":"2017-12-31T14:11:38.000Z","path":"2017/12/31/2017年终总结/","text":"今天是2017的最后一天了，对于2017，是我至今为止最重要的一年，在这一年中经历了人生的第一场高考，很高兴，这也是最后一场。而在下半年，我也进入了大学，虽然大学不是理想中的大学，但是我也很高兴，因为终于可以不再像高中那样了，在这里我可以学习我想要学的东西！ 上半年那时我还在准备高考，每天沉迷于题海之中，那段在一中的时间，是我高中过得最充实的时间，每天早上六点起床，晚上奋斗到差不多一点才睡。但是高三一年的勤奋拉近不了我在高中挥霍了两年的时间所带来的与别人的距离，所以在每次模拟试下来之后都在想，为啥前两年不学多一点呢？这样子在高三就不会这么辛苦，也就不会有这么大的坑让给高三的一年来填。但是我也不会后悔，因为在那两年里，我学会了踢球，懂得了人生有太多的意外，比如我在高二那年的足球班赛，我也认识了一大堆志同道合的人。所以说，对自己走过的路不曾后悔。在这半年，我度过了第一个百日誓师，还记得那天康亚华校长的谈话，还记得我们跑步的激情，还记得那天之后对未来的憧憬。。。 百日誓师，壮观！！！ 下面是我们班在百日誓师的照片 最后放张我们学校的照片吧，离开后才发现学校是真的美！ 最后六月份，走上了考场，离开了学校，最终的结果也对得起我在高三奋斗的一年！ 下半年下半年我走进了大学，大学虽然没有想象的大和好，但这始终会是我在余下四年继续坚持我奋斗的地方，所以我也爱上了这个地方。 看！ 我的大学还是很美的。还有我的班，每个都很帅很漂亮，有木有！！！在这大学半年里，我学了很多编程知识，比如c语言，python，html+css+javascript和java，学了这么多，都是因为去尝试吧，因为我暂时不知道我要往哪个方向发展，现在我知道了，我准备往爬虫，分析大数据方向，或许还有人工智能，还有就是以python为主的前端在学了这么多，自己模仿了两个网页，也做了一个简单的查看新闻app，总之还没有深入，准备下一年深入学习。不过在学习学校的课程是失败的，很多课都没有认真学习，英语也没有学好，觉得蛮遗憾的，浪费了这么多时间。还有，我也根据了网上的教程自己搭建了一个属于自己的博客，也挺不错的。而在自己博客定的小目标也没有完成多少，可能要完成的东西太多了，所以也没有完成，下一次就知道应该定多少了，嘻嘻！我在最后的一个月还参加了一个打卡活动，里面的早起和坚持锻炼我基本上算是坚持下来了，算是比较欣慰了。 引用知识星球人里一段话 人生那么长，做着枯燥而无意义的工作，每时每刻都是煎熬。 人生那么短，如果每一步成长都是令人激动的，那你一定不会说:”后悔”。 尝试，不断试错，不断碰壁，不断重来，你会发现人生有那么多的可能。会发现世界上有那么美丽的事情让我们满心欢喜。 献给现在迷茫，未来成功的你。 不忘初心，方得始终。2018，我来了！！！","tags":[{"name":"hard","slug":"hard","permalink":"http://sergiojune.com/tags/hard/"}]},{"title":"Hello World","date":"2017-11-04T23:28:16.000Z","path":"2017/11/05/helloworld/","text":"昨天博客基本搭建完毕， 搞到10点多， 只能说身心疲惫，但是觉得都值。 终于有了自己的后花园，以后发表什么还不是我说了算吗？ 哈哈 这篇文章想了很久，几个小时，总想不出要写什么， 因为觉得自己拥有了博客， 总得发个东西装逼一下， 但细想一下，又没什么好写， 想一下文采真的烂，不过没事，谁都是这样子过来的， 以后会变好的！ 最后分享一首美国诗！ 纽约时间比加州时间早三个小时， New York is 3 hours ahead of California, 但加州时间并没有变慢。 but it does not make California slow. 有人22岁就毕业了， Someone graduated at the age of 22, 但等了五年才找到好的工作！ but waited 5 years before securing a good job! 有人25岁就当上CEO， Someone became a CEO at 25, 却在50岁去世。 and died at 50. 也有人迟到50岁才当上CEO， While another became a CEO at 50, 然后活到90岁。 and lived to 90 years. 有人依然单身， Someone is still single, 同时也有人已婚。 while someone else got married. 奥巴马55岁就退休， Obama retires at 55, 川普70岁才开始当总统。 but Trump starts at 70. 世上每个人本来就有自己的发展时区。 Absolutely everyone in this world works based on their &gt;Time Zone. 身边有些人看似走在你前面， People around you might seem to go ahead of you, 也有人看似走在你后面。 some might seem to be behind you. 但其实每个人在自己的时区有自己的步程。 But everyone is running their own RACE, in their own&gt;TIME. 不用嫉妒或嘲笑他们。 Don’t envy them or mock them. 他们都在自己的时区里，你也是！ They are in their TIME ZONE, and you are in yours! 生命就是等待正确的行动时机。 Life is about waiting for the right moment to act. 所以，放轻松。 So, RELAX. 你没有落后。 You’re not LATE. 你没有领先。 You’re not EARLY. 在命运为你安排的属于自己的时区里，一切都准时。 You are very much ON TIME, and in your TIME ZONE Destiny set up for you. 我的全栈之路开启了！！！","tags":[{"name":"run","slug":"run","permalink":"http://sergiojune.com/tags/run/"}]}]